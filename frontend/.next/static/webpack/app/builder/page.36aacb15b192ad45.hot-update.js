"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/builder/page",{

/***/ "(app-pages-browser)/./src/components/forms/FormSaver.tsx":
/*!********************************************!*\
  !*** ./src/components/forms/FormSaver.tsx ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoSaveForm: () => (/* binding */ autoSaveForm),\n/* harmony export */   getFormData: () => (/* binding */ getFormData),\n/* harmony export */   saveForm: () => (/* binding */ saveForm),\n/* harmony export */   updateForm: () => (/* binding */ updateForm)\n/* harmony export */ });\n// form-service.ts\nasync function saveForm(formName, formFields, userId) {\n    try {\n        if (!formFields || formFields.length === 0) {\n            throw new Error('No form fields provided');\n        }\n        const simplifiedFields = formFields.map((field)=>({\n                id: field.id,\n                type: field.type,\n                label: field.label,\n                required: field.required || false,\n                options: field.options || [],\n                placeholder: field.placeholder || \"Enter \".concat(field.label.toLowerCase())\n            }));\n        // Ensure we have a valid form name and timestamp\n        const currentTimestamp = new Date().toISOString();\n        const validFormName = (formName === null || formName === void 0 ? void 0 : formName.trim()) || 'Untitled Form';\n        const payload = {\n            form_name: validFormName,\n            fields: simplifiedFields,\n            user_id: userId,\n            updated_at: currentTimestamp,\n            created_at: currentTimestamp\n        };\n        console.log('Saving form with payload:', payload);\n        const backendUrl = \"http://localhost:8000\" + '/api/forms/auto-save';\n        const response = await fetch(backendUrl, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(payload),\n            credentials: 'include'\n        });\n        if (!response.ok) {\n            let errorMessage = 'Failed to save form';\n            try {\n                const errorData = await response.json();\n                errorMessage = errorData.detail || errorData.message || \"\".concat(errorMessage, \": \").concat(response.statusText);\n            } catch (e) {\n                errorMessage = \"\".concat(errorMessage, \": \").concat(response.statusText);\n            }\n            throw new Error(errorMessage);\n        }\n        const result = await response.json();\n        if (!result.form_id) {\n            throw new Error('No form ID returned from server');\n        }\n        // Store form name from API response\n        sessionStorage.setItem('currentFormName', result.form_name);\n        sessionStorage.setItem('currentFormId', result.form_id.toString());\n        return result;\n    } catch (error) {\n        console.error('SaveForm Error:', error);\n        throw error;\n    }\n}\nasync function updateForm(formUpdate) {\n    try {\n        var _formUpdate_form_name;\n        if (!formUpdate.form_id) {\n            throw new Error('Form ID is required for updates');\n        }\n        const simplifiedFields = formUpdate.fields.map((field)=>({\n                id: field.id,\n                type: field.type,\n                label: field.label,\n                required: field.required || false,\n                options: field.options || [],\n                placeholder: field.placeholder || \"Enter \".concat(field.label.toLowerCase())\n            }));\n        const payload = {\n            form_id: formUpdate.form_id,\n            form_name: ((_formUpdate_form_name = formUpdate.form_name) === null || _formUpdate_form_name === void 0 ? void 0 : _formUpdate_form_name.trim()) || 'Untitled Form',\n            fields: simplifiedFields,\n            user_id: formUpdate.user_id,\n            updated_at: new Date().toISOString()\n        };\n        try {\n            var _data_detail;\n            // First try to update the form\n            const backendUrl = \"http://localhost:8000\" + '/api/forms/update';\n            const response = await fetch(backendUrl, {\n                method: 'PUT',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(payload),\n                credentials: 'include'\n            });\n            const data = await response.json();\n            // If the form doesn't exist, create a new one\n            if (!response.ok && (((_data_detail = data.detail) === null || _data_detail === void 0 ? void 0 : _data_detail.includes('not found')) || response.status === 404)) {\n                console.log('Form not found, creating a new one instead');\n                return await saveForm(formUpdate.form_name, formUpdate.fields, formUpdate.user_id);\n            }\n            if (!response.ok) {\n                throw new Error(data.detail || 'Failed to update form');\n            }\n            return data;\n        } catch (error) {\n            var _error_message, _error_message1;\n            // If there's a network error or other issue, try to create a new form\n            if (((_error_message = error.message) === null || _error_message === void 0 ? void 0 : _error_message.includes('not found')) || ((_error_message1 = error.message) === null || _error_message1 === void 0 ? void 0 : _error_message1.includes('Failed to fetch'))) {\n                console.log('Error updating form, creating a new one instead:', error);\n                return await saveForm(formUpdate.form_name, formUpdate.fields, formUpdate.user_id);\n            }\n            throw error;\n        }\n    } catch (error) {\n        console.error('UpdateForm Error:', error);\n        throw error;\n    }\n}\n// Add function to get form data\nasync function getFormData(formId) {\n    try {\n        const backendUrl = \"\".concat(\"http://localhost:8000\", \"/api/forms/\").concat(formId);\n        const response = await fetch(backendUrl);\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(\"Failed to fetch form data: \".concat(errorData.message || response.statusText));\n        }\n        const result = await response.json();\n        console.log('Get Form Response:', result);\n        return result;\n    } catch (error) {\n        console.error('GetForm Error:', error);\n        throw error;\n    }\n}\nasync function autoSaveForm(formId, formName, fields) {\n    const userId = Number(sessionStorage.getItem('userId')) || 1; // Get userId from session or default\n    return updateForm({\n        form_id: formId,\n        form_name: (formName === null || formName === void 0 ? void 0 : formName.trim()) || 'Untitled Form',\n        fields: fields,\n        user_id: userId,\n        updated_at: new Date().toISOString()\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2Zvcm1zL0Zvcm1TYXZlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQStCQSxrQkFBa0I7QUFDWCxlQUFlQSxTQUFTQyxRQUFnQixFQUFFQyxVQUF1QixFQUFFQyxNQUFjO0lBQ3RGLElBQUk7UUFDRixJQUFJLENBQUNELGNBQWNBLFdBQVdFLE1BQU0sS0FBSyxHQUFHO1lBQzFDLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUVBLE1BQU1DLG1CQUFtQkosV0FBV0ssR0FBRyxDQUFDQyxDQUFBQSxRQUFVO2dCQUNoREMsSUFBSUQsTUFBTUMsRUFBRTtnQkFDWkMsTUFBTUYsTUFBTUUsSUFBSTtnQkFDaEJDLE9BQU9ILE1BQU1HLEtBQUs7Z0JBQ2xCQyxVQUFVSixNQUFNSSxRQUFRLElBQUk7Z0JBQzVCQyxTQUFTTCxNQUFNSyxPQUFPLElBQUksRUFBRTtnQkFDNUJDLGFBQWFOLE1BQU1NLFdBQVcsSUFBSSxTQUFtQyxPQUExQk4sTUFBTUcsS0FBSyxDQUFDSSxXQUFXO1lBQ3BFO1FBRUEsaURBQWlEO1FBQ2pELE1BQU1DLG1CQUFtQixJQUFJQyxPQUFPQyxXQUFXO1FBQy9DLE1BQU1DLGdCQUFnQmxCLENBQUFBLHFCQUFBQSwrQkFBQUEsU0FBVW1CLElBQUksT0FBTTtRQUUxQyxNQUFNQyxVQUFVO1lBQ2RDLFdBQVdIO1lBQ1hJLFFBQVFqQjtZQUNSa0IsU0FBU3JCO1lBQ1RzQixZQUFZVDtZQUNaVSxZQUFZVjtRQUNkO1FBRUFXLFFBQVFDLEdBQUcsQ0FBQyw2QkFBNkJQO1FBRXpDLE1BQU1RLGFBQWFDLHVCQUFtQyxHQUFHO1FBQ3pELE1BQU1HLFdBQVcsTUFBTUMsTUFBTUwsWUFBWTtZQUN2Q00sUUFBUTtZQUNSQyxTQUFTO2dCQUNQLGdCQUFnQjtZQUNsQjtZQUNBQyxNQUFNQyxLQUFLQyxTQUFTLENBQUNsQjtZQUNyQm1CLGFBQWE7UUFDZjtRQUVBLElBQUksQ0FBQ1AsU0FBU1EsRUFBRSxF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QUksT0FBTTtRQUMvQkcsUUFBUUE7UUFDUkMsU0FBU3JCO1FBQ1RzQixZQUFZLElBQUlSLE9BQU9DLFdBQVc7SUFDcEM7QUFDRiIsInNvdXJjZXMiOlsiRDpcXE5ldyBWZXJ0aWNsZVxcU2FtcGxlXFxDcmVhdGlvbiBFbmdpbmVcXGZyb250ZW5kXFxzcmNcXGNvbXBvbmVudHNcXGZvcm1zXFxGb3JtU2F2ZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZvcm1FbGVtZW50IH0gZnJvbSAnQC90eXBlcy9mb3JtJ1xyXG5cclxuLy8gdHlwZXMudHNcclxuaW50ZXJmYWNlIEZvcm1GaWVsZCB7XHJcbiAgaWQ6IHN0cmluZztcclxuICB0eXBlOiBzdHJpbmc7XHJcbiAgbGFiZWw6IHN0cmluZztcclxuICByZXF1aXJlZD86IGJvb2xlYW47XHJcbiAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XHJcbiAgY2FwdGlvbj86IHN0cmluZztcclxuICBvcHRpb25zPzogc3RyaW5nW107XHJcbiAgdmFsdWU/OiBzdHJpbmcgfCBzdHJpbmdbXSB8IGJvb2xlYW47XHJcbn1cclxuXHJcbmludGVyZmFjZSBGb3JtUmVzcG9uc2Uge1xyXG4gIG1lc3NhZ2U6IHN0cmluZztcclxuICBmb3JtX2lkOiBudW1iZXI7XHJcbiAgZm9ybV9uYW1lOiBzdHJpbmc7XHJcbiAgdXNlcl9pZDogbnVtYmVyO1xyXG4gIGZvcm1fZGF0YT86IEZvcm1GaWVsZFtdOyAgLy8gRm9yIGdldCByZXNwb25zZVxyXG4gIHVwZGF0ZWRfYXQ/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmludGVyZmFjZSBGb3JtVXBkYXRlIHtcclxuICBmb3JtX2lkOiBudW1iZXI7XHJcbiAgZm9ybV9uYW1lOiBzdHJpbmc7XHJcbiAgZmllbGRzOiBGb3JtRmllbGRbXTtcclxuICB1c2VyX2lkOiBudW1iZXI7XHJcbiAgdXBkYXRlZF9hdDogc3RyaW5nO1xyXG59XHJcblxyXG4vLyBmb3JtLXNlcnZpY2UudHNcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhdmVGb3JtKGZvcm1OYW1lOiBzdHJpbmcsIGZvcm1GaWVsZHM6IEZvcm1GaWVsZFtdLCB1c2VySWQ6IG51bWJlcik6IFByb21pc2U8Rm9ybVJlc3BvbnNlPiB7XHJcbiAgdHJ5IHtcclxuICAgIGlmICghZm9ybUZpZWxkcyB8fCBmb3JtRmllbGRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGZvcm0gZmllbGRzIHByb3ZpZGVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2ltcGxpZmllZEZpZWxkcyA9IGZvcm1GaWVsZHMubWFwKGZpZWxkID0+ICh7XHJcbiAgICAgIGlkOiBmaWVsZC5pZCxcclxuICAgICAgdHlwZTogZmllbGQudHlwZSxcclxuICAgICAgbGFiZWw6IGZpZWxkLmxhYmVsLFxyXG4gICAgICByZXF1aXJlZDogZmllbGQucmVxdWlyZWQgfHwgZmFsc2UsXHJcbiAgICAgIG9wdGlvbnM6IGZpZWxkLm9wdGlvbnMgfHwgW10sXHJcbiAgICAgIHBsYWNlaG9sZGVyOiBmaWVsZC5wbGFjZWhvbGRlciB8fCBgRW50ZXIgJHtmaWVsZC5sYWJlbC50b0xvd2VyQ2FzZSgpfWBcclxuICAgIH0pKTtcclxuXHJcbiAgICAvLyBFbnN1cmUgd2UgaGF2ZSBhIHZhbGlkIGZvcm0gbmFtZSBhbmQgdGltZXN0YW1wXHJcbiAgICBjb25zdCBjdXJyZW50VGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgY29uc3QgdmFsaWRGb3JtTmFtZSA9IGZvcm1OYW1lPy50cmltKCkgfHwgJ1VudGl0bGVkIEZvcm0nO1xyXG5cclxuICAgIGNvbnN0IHBheWxvYWQgPSB7XHJcbiAgICAgIGZvcm1fbmFtZTogdmFsaWRGb3JtTmFtZSxcclxuICAgICAgZmllbGRzOiBzaW1wbGlmaWVkRmllbGRzLFxyXG4gICAgICB1c2VyX2lkOiB1c2VySWQsXHJcbiAgICAgIHVwZGF0ZWRfYXQ6IGN1cnJlbnRUaW1lc3RhbXAsXHJcbiAgICAgIGNyZWF0ZWRfYXQ6IGN1cnJlbnRUaW1lc3RhbXBcclxuICAgIH07XHJcblxyXG4gICAgY29uc29sZS5sb2coJ1NhdmluZyBmb3JtIHdpdGggcGF5bG9hZDonLCBwYXlsb2FkKTtcclxuXHJcbiAgICBjb25zdCBiYWNrZW5kVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFDS0VORF9VUkwgKyAnL2FwaS9mb3Jtcy9hdXRvLXNhdmUnO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChiYWNrZW5kVXJsLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXHJcbiAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZSdcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgbGV0IGVycm9yTWVzc2FnZSA9ICdGYWlsZWQgdG8gc2F2ZSBmb3JtJztcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3JEYXRhLmRldGFpbCB8fCBlcnJvckRhdGEubWVzc2FnZSB8fCBgJHtlcnJvck1lc3NhZ2V9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YDtcclxuICAgICAgfSBjYXRjaCB7XHJcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gYCR7ZXJyb3JNZXNzYWdlfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWA7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgXHJcbiAgICBpZiAoIXJlc3VsdC5mb3JtX2lkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZm9ybSBJRCByZXR1cm5lZCBmcm9tIHNlcnZlcicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0b3JlIGZvcm0gbmFtZSBmcm9tIEFQSSByZXNwb25zZVxyXG4gICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnY3VycmVudEZvcm1OYW1lJywgcmVzdWx0LmZvcm1fbmFtZSk7XHJcbiAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdjdXJyZW50Rm9ybUlkJywgcmVzdWx0LmZvcm1faWQudG9TdHJpbmcoKSk7XHJcbiAgICBcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ1NhdmVGb3JtIEVycm9yOicsIGVycm9yKTtcclxuICAgIHRocm93IGVycm9yO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUZvcm0oZm9ybVVwZGF0ZTogRm9ybVVwZGF0ZSk6IFByb21pc2U8Rm9ybVJlc3BvbnNlPiB7XHJcbiAgdHJ5IHtcclxuICAgIGlmICghZm9ybVVwZGF0ZS5mb3JtX2lkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybSBJRCBpcyByZXF1aXJlZCBmb3IgdXBkYXRlcycpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHNpbXBsaWZpZWRGaWVsZHMgPSBmb3JtVXBkYXRlLmZpZWxkcy5tYXAoZmllbGQgPT4gKHtcclxuICAgICAgaWQ6IGZpZWxkLmlkLFxyXG4gICAgICB0eXBlOiBmaWVsZC50eXBlLFxyXG4gICAgICBsYWJlbDogZmllbGQubGFiZWwsXHJcbiAgICAgIHJlcXVpcmVkOiBmaWVsZC5yZXF1aXJlZCB8fCBmYWxzZSxcclxuICAgICAgb3B0aW9uczogZmllbGQub3B0aW9ucyB8fCBbXSxcclxuICAgICAgcGxhY2Vob2xkZXI6IGZpZWxkLnBsYWNlaG9sZGVyIHx8IGBFbnRlciAke2ZpZWxkLmxhYmVsLnRvTG93ZXJDYXNlKCl9YFxyXG4gICAgfSkpO1xyXG5cclxuICAgIGNvbnN0IHBheWxvYWQgPSB7XHJcbiAgICAgIGZvcm1faWQ6IGZvcm1VcGRhdGUuZm9ybV9pZCxcclxuICAgICAgZm9ybV9uYW1lOiBmb3JtVXBkYXRlLmZvcm1fbmFtZT8udHJpbSgpIHx8ICdVbnRpdGxlZCBGb3JtJyxcclxuICAgICAgZmllbGRzOiBzaW1wbGlmaWVkRmllbGRzLFxyXG4gICAgICB1c2VyX2lkOiBmb3JtVXBkYXRlLnVzZXJfaWQsXHJcbiAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gICAgfTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBGaXJzdCB0cnkgdG8gdXBkYXRlIHRoZSBmb3JtXHJcbiAgICAgIGNvbnN0IGJhY2tlbmRVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19CQUNLRU5EX1VSTCArICcvYXBpL2Zvcm1zL3VwZGF0ZSc7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYmFja2VuZFVybCwge1xyXG4gICAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxyXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZSdcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICBcclxuICAgICAgLy8gSWYgdGhlIGZvcm0gZG9lc24ndCBleGlzdCwgY3JlYXRlIGEgbmV3IG9uZVxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rICYmIChkYXRhLmRldGFpbD8uaW5jbHVkZXMoJ25vdCBmb3VuZCcpIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdGb3JtIG5vdCBmb3VuZCwgY3JlYXRpbmcgYSBuZXcgb25lIGluc3RlYWQnKTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgc2F2ZUZvcm0oZm9ybVVwZGF0ZS5mb3JtX25hbWUsIGZvcm1VcGRhdGUuZmllbGRzLCBmb3JtVXBkYXRlLnVzZXJfaWQpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZGV0YWlsIHx8ICdGYWlsZWQgdG8gdXBkYXRlIGZvcm0nKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICAgIC8vIElmIHRoZXJlJ3MgYSBuZXR3b3JrIGVycm9yIG9yIG90aGVyIGlzc3VlLCB0cnkgdG8gY3JlYXRlIGEgbmV3IGZvcm1cclxuICAgICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdub3QgZm91bmQnKSB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnRmFpbGVkIHRvIGZldGNoJykpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgdXBkYXRpbmcgZm9ybSwgY3JlYXRpbmcgYSBuZXcgb25lIGluc3RlYWQ6JywgZXJyb3IpO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCBzYXZlRm9ybShmb3JtVXBkYXRlLmZvcm1fbmFtZSwgZm9ybVVwZGF0ZS5maWVsZHMsIGZvcm1VcGRhdGUudXNlcl9pZCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ1VwZGF0ZUZvcm0gRXJyb3I6JywgZXJyb3IpO1xyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBBZGQgZnVuY3Rpb24gdG8gZ2V0IGZvcm0gZGF0YVxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Rm9ybURhdGEoZm9ybUlkOiBudW1iZXIpOiBQcm9taXNlPEZvcm1SZXNwb25zZT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBiYWNrZW5kVXJsID0gYCR7cHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFDS0VORF9VUkx9L2FwaS9mb3Jtcy8ke2Zvcm1JZH1gO1xyXG4gICAgXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGJhY2tlbmRVcmwpO1xyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGZvcm0gZGF0YTogJHtlcnJvckRhdGEubWVzc2FnZSB8fCByZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIGNvbnNvbGUubG9nKCdHZXQgRm9ybSBSZXNwb25zZTonLCByZXN1bHQpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignR2V0Rm9ybSBFcnJvcjonLCBlcnJvcik7XHJcbiAgICB0aHJvdyBlcnJvcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhdXRvU2F2ZUZvcm0oZm9ybUlkOiBudW1iZXIsIGZvcm1OYW1lOiBzdHJpbmcsIGZpZWxkczogRm9ybUVsZW1lbnRbXSkge1xyXG4gIGNvbnN0IHVzZXJJZCA9IE51bWJlcihzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCd1c2VySWQnKSkgfHwgMTsgLy8gR2V0IHVzZXJJZCBmcm9tIHNlc3Npb24gb3IgZGVmYXVsdFxyXG4gIHJldHVybiB1cGRhdGVGb3JtKHtcclxuICAgIGZvcm1faWQ6IGZvcm1JZCxcclxuICAgIGZvcm1fbmFtZTogZm9ybU5hbWU/LnRyaW0oKSB8fCAnVW50aXRsZWQgRm9ybScsXHJcbiAgICBmaWVsZHM6IGZpZWxkcyxcclxuICAgIHVzZXJfaWQ6IHVzZXJJZCxcclxuICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gIH0pO1xyXG59Il0sIm5hbWVzIjpbInNhdmVGb3JtIiwiZm9ybU5hbWUiLCJmb3JtRmllbGRzIiwidXNlcklkIiwibGVuZ3RoIiwiRXJyb3IiLCJzaW1wbGlmaWVkRmllbGRzIiwibWFwIiwiZmllbGQiLCJpZCIsInR5cGUiLCJsYWJlbCIsInJlcXVpcmVkIiwib3B0aW9ucyIsInBsYWNlaG9sZGVyIiwidG9Mb3dlckNhc2UiLCJjdXJyZW50VGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidmFsaWRGb3JtTmFtZSIsInRyaW0iLCJwYXlsb2FkIiwiZm9ybV9uYW1lIiwiZmllbGRzIiwidXNlcl9pZCIsInVwZGF0ZWRfYXQiLCJjcmVhdGVkX2F0IiwiY29uc29sZSIsImxvZyIsImJhY2tlbmRVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQkFDS0VORF9VUkwiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiY3JlZGVudGlhbHMiLCJvayIsImVycm9yTWVzc2FnZSIsImVycm9yRGF0YSIsImpzb24iLCJkZXRhaWwiLCJtZXNzYWdlIiwic3RhdHVzVGV4dCIsInJlc3VsdCIsImZvcm1faWQiLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJ0b1N0cmluZyIsImVycm9yIiwidXBkYXRlRm9ybSIsImZvcm1VcGRhdGUiLCJkYXRhIiwiaW5jbHVkZXMiLCJzdGF0dXMiLCJnZXRGb3JtRGF0YSIsImZvcm1JZCIsImNhdGNoIiwiYXV0b1NhdmVGb3JtIiwiTnVtYmVyIiwiZ2V0SXRlbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/forms/FormSaver.tsx\n"));

/***/ })

});